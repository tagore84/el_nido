{
    "name": "nido.meals.tracker",
    "nodes": [
        {
            "parameters": {},
            "name": "Execute Workflow Trigger",
            "type": "n8n-nodes-base.executeWorkflowTrigger",
            "typeVersion": 1,
            "position": [
                256,
                240
            ],
            "id": "trigger-node-id"
        },
        {
            "parameters": {
                "jsCode": "const json = $input.item.json;\nconst message_text = json.message ? json.message.text : json.text;\nconst chat_id = json.chat_id || (json.message && json.message.chat ? json.message.chat.id : null);\nconst imagePath = json.imagePath || json.image_path || json._meta?.input_path || null;\n\n// User Mapping\nconst chatMap = {\n    \"5785514136\": \"Alberto\",\n    \"-5223730192\": \"Alberto y Laura\",\n    \"-5234536185\": \"Alberto y Laura\",\n    \"PLACEHOLDER\": \"Laura\"\n};\nconst who = chatMap[String(chat_id)] || \"Desconocido\";\n\nconst prompt_id = 'meals.tracker';\nconst options = {};\n\nlet inputType = 'TEXT';\nlet js_input = {\n    input_text: message_text\n};\n\nif (imagePath) {\n    inputType = 'IMAGE';\n    js_input.input_text = \"Analiza esta imagen y extrae la comida o cena.\";\n    js_input.input_path = imagePath;\n}\n\nreturn {\n  json: {\n    prompt_id,\n    options,\n    chat_id,\n    who,\n    input: {\n        input_type: inputType,\n        ...js_input\n    },\n    original_msg: message_text\n  }\n};"
            },
            "name": "Prepare LLM Input",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                480,
                240
            ],
            "id": "prepare-node-id"
        },
        {
            "parameters": {
                "workflowId": "cIdjAXxgI1Z-LurEg16oO",
                "mode": "each",
                "options": {}
            },
            "name": "Extract Meal Data",
            "type": "n8n-nodes-base.executeWorkflow",
            "typeVersion": 1,
            "position": [
                700,
                240
            ],
            "id": "llm-node-id"
        },
        {
            "parameters": {
                "jsCode": "const fs = require('fs');\nconst item = $input.item.json;\n\n// LLM Output\n// Adapted for generic LLM response structure. Assuming the adapter returns parseable JSON in 'output' or properties directly.\nconst data = item.output || item;\n\nconst food = data.food || 'Desconocido';\nconst type = data.type || 'other';\nconst meal_source = data.source || 'casera'; // extracted from LLM\nconst date_str = data.date || new Date().toISOString().split('T')[0];\nconst type_capitalized = type.charAt(0).toUpperCase() + type.slice(1);\n\n// Metadata\nconst prepareNode = $('Prepare LLM Input').first().json;\nconst who = prepareNode.who;\nconst app_source = 'telegram';\nconst timestamp = new Date().toISOString();\n\n// CSV Line\n// timestamp,date_str,who,lunch,food,source,type\nconst line = `${timestamp},${date_str},${who},${type},\"${food}\",${app_source},${meal_source}\\n`;\n\nconst csvPath = '/data/meals/meals.csv';\n\ntry {\n    if (!fs.existsSync(csvPath)) {\n        // Header\n        fs.writeFileSync(csvPath, 'timestamp,date_str,who,lunch,food,source,type\\n');\n    }\n    fs.appendFileSync(csvPath, line);\n} catch (e) {\n    throw new Error(`Failed to write to CSV: ${e.message}`);\n}\n\n// Read Catalog for next step (ONLY if homemade)\nlet catalog = [];\nif (meal_source === 'casera') {\n    try {\n        const catalogPath = '/data/inventory/food_stock_catalog.json';\n        if (fs.existsSync(catalogPath)) {\n            catalog = JSON.parse(fs.readFileSync(catalogPath, 'utf8'));\n            if (catalog.products) catalog = catalog.products;\n        }\n    } catch (e) {\n        // Ignore if fails, logic will proceed with empty catalog\n    }\n}\n\nreturn {\n  json: {\n    ...item,\n    logged_food: food,\n    logged_type: type,\n    logged_date: date_str,\n    logged_who: who,\n    logged_source: meal_source,\n    catalog: catalog\n  }\n};\n"
            },
            "name": "Log and Load Catalog",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                920,
                240
            ],
            "id": "log-node-id"
        },
        {
            "parameters": {
                "dataType": "string",
                "value1": "={{ $json.logged_source }}",
                "rules": {
                    "rules": [
                        {
                            "value2": "casera"
                        }
                    ]
                },
                "fallbackOutput": 1
            },
            "name": "Switch Source",
            "type": "n8n-nodes-base.switch",
            "typeVersion": 1,
            "position": [
                1140,
                240
            ],
            "id": "switch-source-id"
        },
        {
            "parameters": {
                "jsCode": "const catalog = $input.first().json.catalog || [];\nconst miniCatalog = catalog.map(p => ({\n    id: p.id,\n    name: p.display_name || p.name,\n    synonyms: p.synonyms\n}));\nconst meal = $input.first().json.logged_food;\n// isCasera check is now redundant but keeping code valid\n\nconst fullInput = `Catalog:\\n${JSON.stringify(miniCatalog, null, 2)}\\n\\nMeal:\\n\"${meal}\"`;\n\nreturn {\n  json: {\n    prompt_id: 'meals.ingredient_mapper',\n    input: {\n        input_type: 'TEXT',\n        input_text: fullInput\n    }\n  }\n};"
            },
            "name": "Prepare Ingredients Input",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1360,
                240
            ],
            "id": "prepare-ingredients-input"
        },
        {
            "parameters": {
                "workflowId": "cIdjAXxgI1Z-LurEg16oO",
                "mode": "each",
                "options": {}
            },
            "name": "Extract Ingredients",
            "type": "n8n-nodes-base.executeWorkflow",
            "typeVersion": 1,
            "position": [
                1580,
                240
            ],
            "id": "extract-ingredients"
        },
        {
            "parameters": {
                "jsCode": "const fs = require('fs');\nconst item = $input.item.json;\nconst ingredientsData = item.output || item;\nconst ingredients = ingredientsData.ingredients || [];\n\n// Get previous context\nconst logNode = $('Log and Load Catalog').first().json;\nconst mealName = logNode.logged_food;\nconst who = logNode.logged_who;\nconst type = logNode.logged_type;\n\n// Valid flags\nconst isLunch = type.toLowerCase() === 'comida';\nconst isDinner = type.toLowerCase() === 'cena';\nconst isAlberto = who.includes('Alberto');\nconst isLaura = who.includes('Laura');\n\n// Normalize Meal Name (Capitalize)\nconst normalizedName = mealName.trim().charAt(0).toUpperCase() + mealName.trim().slice(1);\n\n// Read Meals Catalog\nconst mealsCatalogPath = '/data/inventory/meals_catalog.json';\nlet mealsCatalog = [];\ntry {\n    if (fs.existsSync(mealsCatalogPath)) {\n        mealsCatalog = JSON.parse(fs.readFileSync(mealsCatalogPath, 'utf8'));\n    }\n} catch (e) {\n    mealsCatalog = [];\n}\n\n// Find existing meal\nlet mealEntry = mealsCatalog.find(m => m.name.toLowerCase() === normalizedName.toLowerCase());\nlet isNew = false;\n\nif (!mealEntry) {\n    isNew = true;\n    mealEntry = {\n        name: normalizedName,\n        valid_for_lunch: false,\n        valid_for_dinner: false,\n        valid_for_alberto: false,\n        valid_for_laura: false,\n        ingredients: []\n    };\n    mealsCatalog.push(mealEntry);\n}\n\n// Update Flags (OR logic)\nif (isLunch) mealEntry.valid_for_lunch = true;\nif (isDinner) mealEntry.valid_for_dinner = true;\nif (isAlberto) mealEntry.valid_for_alberto = true;\nif (isLaura) mealEntry.valid_for_laura = true;\n\n// Update Ingredients (Merge unique)\n// If it's a new meal, just take them.\n// If existing, we append new ones found? Or replace? \n// User said: \"Para rellenar el array... se podr√° preguntar al usuario\".\n// Implies we define the ingredients. If we extract more ingredients now, we should probably add them if not present.\nconst newIngredients = ingredients.filter(i => !mealEntry.ingredients.includes(i));\nmealEntry.ingredients = [...mealEntry.ingredients, ...newIngredients];\n\n// Save Catalog\ntry {\n    fs.writeFileSync(mealsCatalogPath, JSON.stringify(mealsCatalog, null, 2));\n} catch (e) {\n    throw new Error('Failed to save meals catalog: ' + e.message);\n}\n\nreturn {\n  json: {\n    ...item,\n    meal_name: normalizedName,\n    new_ingredients: newIngredients,\n    is_new: isNew,\n    updated_entry: mealEntry\n  }\n};\n"
            },
            "name": "Update Meals Catalog",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1800,
                240
            ],
            "id": "update-catalog"
        },
        {
            "parameters": {
                "jsCode": "const loggedFood = $json.meal_name || $json.logged_food;\nconst loggedType = $('Log and Load Catalog').item.json.logged_type;\nconst loggedDate = $('Log and Load Catalog').item.json.logged_date;\nconst loggedWho = $('Log and Load Catalog').item.json.logged_who;\nconst loggedSource = $('Log and Load Catalog').item.json.logged_source;\n\nconst sourceEmoji = loggedSource === 'casera' ? 'üè† Casera' : (loggedSource === 'domicilio' ? 'üõµ Domicilio' : 'üçΩÔ∏è Fuera');\n\nlet text = `‚úÖ Apuntado: ${loggedFood}\\nTipo: ${loggedType}\\nFecha: ${loggedDate}\\nQui√©n: ${loggedWho}\\nFuente: ${sourceEmoji}`;\n\nif ($json.is_new) {\n    text += \"\\nüÜï Nueva comida registrada\";\n} else if ($json.updated_entry) {\n    text += \"\\nüîÑ Comida actualizada\";\n}\n\nif ($json.updated_entry && $json.updated_entry.ingredients) {\n    text += `\\nIngredientes detectados: ${$json.updated_entry.ingredients.join(', ') || 'Ninguno'}`;\n}\n\nreturn { json: { result_text: text, chat_id: $('Prepare LLM Input').item.json.chat_id } };"
            },
            "name": "Format Response",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                2020,
                240
            ],
            "id": "format-response"
        },
        {
            "parameters": {
                "dataType": "string",
                "value1": "={{ $json.chat_id }}",
                "rules": {
                    "rules": [
                        {
                            "value2": "nido-web"
                        }
                    ]
                },
                "fallbackOutput": 1
            },
            "name": "Switch Chat ID",
            "type": "n8n-nodes-base.switch",
            "typeVersion": 1,
            "position": [
                2240,
                240
            ],
            "id": "switch-chat-id"
        },
        {
            "parameters": {
                "chatId": "={{ $json.chat_id }}",
                "text": "={{ $json.result_text }}",
                "additionalFields": {
                    "parse_mode": "HTML"
                }
            },
            "name": "Confirm to User",
            "type": "n8n-nodes-base.telegram",
            "typeVersion": 1,
            "position": [
                2460,
                240
            ],
            "id": "telegram-reply-node-id",
            "credentials": {
                "telegramApi": {
                    "id": "JLG33gMQcdi4JvQq",
                    "name": "Telegram account"
                }
            }
        }
    ],
    "connections": {
        "Execute Workflow Trigger": {
            "main": [
                [
                    {
                        "node": "Prepare LLM Input",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Prepare LLM Input": {
            "main": [
                [
                    {
                        "node": "Extract Meal Data",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Extract Meal Data": {
            "main": [
                [
                    {
                        "node": "Log and Load Catalog",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Log and Load Catalog": {
            "main": [
                [
                    {
                        "node": "Switch Source",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Switch Source": {
            "main": [
                [
                    {
                        "node": "Prepare Ingredients Input",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Format Response",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Prepare Ingredients Input": {
            "main": [
                [
                    {
                        "node": "Extract Ingredients",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Extract Ingredients": {
            "main": [
                [
                    {
                        "node": "Update Meals Catalog",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Update Meals Catalog": {
            "main": [
                [
                    {
                        "node": "Format Response",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Format Response": {
            "main": [
                [
                    {
                        "node": "Switch Chat ID",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Switch Chat ID": {
            "main": [
                [],
                [
                    {
                        "node": "Confirm to User",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    }
}